# 设计模式 之 观察者模式

> 伴随着 `Vue` 等 `MVVM` 框架的流行，观察者模式也成为前端开发口中的热词。

### 项目中的观察者模式

一个新的开发周期，前端同学们都分配到了自己负责的模块，这时候我们要做的就是找设计同学给图。因为需求刚下来，设计同学刚刚建好项目的文件夹，面对一群嗷嗷待哺的前端，设计师同学只得先拉了个群，并给出承诺 “三天后给图”。

这里的设计同学就代表观察者模式中的发布者，前端同学对应的是订阅者，即观察者对象。发布者只有一个，而订阅者却有多个。这里就引出了观察模式的定义：

> 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，是他们能够自动更新。

#### `Vue` 中的观察者模式

`Vue` 框架会将我们写的 `template` 转化为抽象语法树，并收集其中需要 **双向绑定** 的部分，这一步叫做依赖收集，被收集的依赖也被叫做 `Watcher` 。框架会通过 `Dep` 类（其与数据劫持部分：Observe 统称为发布者）统一管理这些依赖，数据发生变化时，`Dep` 会通知到对应的 `Wather` 刷新 `Dom` 。

其代码实现：

```js
class Observe {
    // 劫持数据
    new Proxy(data, {
        get() {},
    	set() {
            Dep.notify // 通知数据发生变化
        }
    })
}

class Dep {
    subs: [] // 用来存放订阅者
    
    addSub() {} // 添加订阅者
    
    removeSub() {} // 移除订阅者
    
    notify() { // 通知订阅者
        Wathcer.Update
    }
}

class Watcher {
    Update() {}
}
```



#### 观察者模式 与 `Promise`

在业务开发的过程中，我们可能会遇到如下场景：

渲染层需要向数据层请求所需要展示的数据，数据层的数据则来自于服务器的推送，若服务器未推送数据，则数据层需要等待服务器推送数据后再响应渲染层的请求。

其实现大致如下：

```js
// renderer.js
data.fetch().then()

// data.js
class Data {
    constructor () {
        listen('server', this._watch_)
    }
    
    _stack_ = []
    
    fetch () {
        return new Promise((resolve, reject) => {
            this._stack_.push({
                success: resolve,
                fail: reject
            })
        })
    }
    
    _watch_ (err, data) {
        while(this._stack_.length) {
            const { success, fail } = this._stack_.shift()
            if (err) {
                fail(err)
            } else {
                success(data)
            }
        }
    }
}
```

在这里，渲染层通过调用 `data.fetch` 方法创建订阅者，`Data` 类作为发布者，通过其中 `_watch_` 方法将监听到的数据发布到各个订阅者。
